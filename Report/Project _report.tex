\documentclass[conference]{IEEEtran}
%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}



\begin{document}

\title{Conference Paper Title*\\
{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured for https://ieeexplore.ieee.org  and
should not be used}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Danyal Mirza}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Linnéa Soto Carlsson}
\IEEEauthorblockA{\textit{Department of Computer Science} \\
\textit{Uppsala University (UU)}\\
Uppsala, Sweden \\
Linnea.sotocarlsson.7666@student.uu.se}

\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}

}

\maketitle

% For citations use \cite{x}, where x is defined as \bibitem{x} in references

\begin{abstract}
\textbf{Linnea + Danyal}
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert.
\end{IEEEkeywords}

\section{Introduction}
\textbf{Linnea + Danyal}\\
The objective of the project was to design and develop "Bart", a bartender capable of reading the user's emotional state and providing drink recommendations aligning with the detected mood while engaging in a pleasant conversation. In addition, the system takes into account the individual drink preferences of the users to ensure a satisfying experience. These specific objectives were chosen in the beginning of the project, as the group members believed they were essential for creating a meaningful project connected to the course work. 
The work for this project was divided into two primary subsystems: the Perception Subsystem and the Interaction Subsystem. 

\begin{itemize}
    \item \textbf{Linnéa} and \textbf{Danyal} were responsible for developing the perception subsystem. They built a video server together with a client to connect to the interaction system. The video server is capable of detecting faces and recognizing emotions, with the help of a Random Forest (RF) machine learning model to classify mood based on facial expressions.
    
    
    \item \textbf{Adrià} and \textbf{Walter} focused on the interaction subsystem. Their work involved setting up the Furhat robot, integrating a Large Language Model (LLM) into Furhat, and designing the system to translate detected emotions and user preferences into prompts for generating personalized drink recommendations.

\end{itemize}

Teamwork within the group was collaborative and efficient, where meaningful discussions helped solving problems encountered throughout the project. The writing of the report was divided equally among the members, and each person primarily contributed to their specific area of work.
\\
\section{Methodology}
\textbf{Linnea + Danyal}
\\
This section describes the methodology and system architecture used in the project.

\subsection{Overall system design}
\textbf{Linnea + Danyal}


The scenario chosen for this project is as said in previous sections a bartender. The primary task of Bart, our bartender, is to analyze the customer's emotional state and offer drink recommendations based on their mood. Additionally, the system personalizes the recommendations by taking into account the customer's individual drink preferences from engaging in a pleasant conversation with the customer. This ensures a more enjoyable experience.\\The system consists of multiple parts combined into one functional, smooth system accomplishing the below stated high level goals.\\
\\
\textbf{HIGH-LEVEL GOALS:}
\\
\begin{enumerate}
    \item \textbf{Emotion Recognition:} Detect the client’s emotional state accurately based on facial expressions.
    \item \textbf{Personalized Drink Recommendations:} Suggest a drink that fits both the emotional state and the individual preferences of the client.
    \item \textbf{Engaging Conversation:} Maintain a pleasant and natural conversation with the client while offering drink recommendations.
    \item \textbf{Real-Time Interaction:} Provide real-time responses to emotions and preferences without significant delays, ensuring smooth and interactive engagement.
\\
\end{enumerate}

\textcolor{red}{\textbf{What specific choices did you make to achieve the high-level goals?}}
\\
To achieve these goals, the system consists of two sub-systems: the \textbf{perception subsystem} and the \textbf{interaction subsystem}. The perception sub-system consists of a video socket server recognizing faces combined with a machine learning model classifying emotions of recognized faces. The interaction sub-system consists of a client establishing contact with the video server, the client is integrated with Furhat, a social robot platform which is designed to enable human-like interaction through multimodal communication. Furhat have advanced speech synthesis, facial animations and gesture recognition. Furhat provides a remote API which makes it possible for us to control, design and interact with the robot over a network. Together with the client and Furhat, a Large Language Model (LLM), Gemini is integrated to the interaction subsystem to enable a response to the user speach input. 
\\
\\
\\
\subsection{User perception sub-system}
\textbf{Linnea + Danyal}
\subsubsection{Server design}

\subsubsection{Machine Learning Design}
The random forest machine learning model for emotion detection was developed through several steps with the goal to optimize performance. Before deciding on random forests as the primary model, several other machine learning approaches were explored, including Support Vector Machines (SVM), boosting, and neural networks. This process is discussed more thoroughly in the discussion headline of this report.\\ The first step in building the model was identifying and preparing a dataset suitable for the emotion detection task. \\ \textcolor{red}{\textbf{(Adrià, please provide details about the dataset, such as its source, size, and any preprocessing steps applied)}}\\
Once the dataset was prepared, it was split into an 80\% training set and a 20\% test set using stratified sampling to keep the original class distribution. An initial analysis of the class distribution revealed significant imbalances in the emotion categories:
\begin{itemize}
    \item Neutral: 20.97\%
	\item Happy: 20.95\%
	\item Surprise: 16.86\%
	\item Sad: 11.95\%
	\item Fear: 11.74\%
	\item Angry: 10.42\%
	\item Disgust: 7.11\%
\end{itemize}	
To address this imbalance, the Synthetic Minority Oversampling Technique (SMOTE) was applied to the training set, resulting in a more even distribution across classes. SMOTE is a technique to balance uneven distribution of classes by synthesizing samples in minority classes. The selection of synthesized value is decided through k-nearest neighbors within the class in question. This was done to avoid overfitting and bias in the training dataset.  
\\Following this, a baseline random forest model was trained.
This baseline model was then optimized with the help of a thorough grid search in the process of finding a better accuracy and stability. A random search was initially included in the process, which later was removed from the code to make it more concise, as its performance did not match that of the grid search using GridSearchCV.
\\
The hyperparameters tuned during this process included:
\begin{itemize}
    \item Number of estimators (n\_estimators)
	\item Maximum tree depth (max\_depth)
	\item Minimum samples for node splits and leaves (min\_samples\_split, min\_samples\_leaf)
	\item Number of features considered for splitting (max\_features)
	\item Use of bootstrapping (bootstrap)
\end{itemize}	
    
The optimization process had 5-fold cross-validation.
Model performance was assessed using a classification report that included precision, recall, F1-score, and accuracy.
\\The above mentioned process was repeated but this time without the SMOTE to compare the performances of the resulting models. This process proved the model without the SMOTE to be the best performing model. This model had the Best Hyperparameters: 
\texttt{(bootstrap: True, max\_depth: 30, max\_features: sqrt, min\_samples\_leaf: 1, min\_samples\_split: 2, n\_estimators: 100)}. The model has the accuracy of 46.46\%.\\

\subsubsection{Combined Functionality of server and ML-model}

\subsection{Interaction sub-system} %Walter + Danyal
This section discusses the second subsystem of Bart the bartender. 
It goes over the high-level design and its implementation. 
Afterwards it evaluates the obtained results.

\subsubsection{Design}
The interaction sub-system in this project consists of the virtual Furhat, Gemini and a connection to the video server.
Furhat is used as the interface between the system and the user and Gemini is used to generate a response to the input of the user.
The response is based on what the user says and what emotion is detected in the face of the user at the beginning of the conversation.
This response is then sent to Furhat so that it can reply to the user.
This process is repeated until the right drink is found for the user.

\subsubsection{Implementation}
The typical flow of this subsystem is as follows: 
A connection is set up between this subsystem and the video server that was described in the previous section.
Once this connection is set up, Bart greets the user and asks what kind of cocktail the user wants.
From this moment, the subsystem gathers the detected emotions of the user, until the user is done with speaking.
From these emotions, we determine the dominant emotion of the user.
When the user finishes their reply to Bart, we combine the dominant emotion with the reply of the user and send it to Gemini.
Gemini is a LLM that is instructed to act like a bartender that recommends cocktails that fit the mood of the customer.
We decided to use Gemini because it is free for people with a google account up to a rate limit.
Our application does not use up a lot of tokens, so we should not reach this rate limit.
Once Gemini has generated a response, it is forwarded to Bart.
Then, Bart is instructed to say the response.
After Bart is done with talking, it listens again for input of the user. 
The input of the user is again combined with the dominant emotion and sent to Gemini.
This cycle continues until the user decides on a cocktail.
After this the whole cycle repeats from the beginning, assuming there is a new customer.

% The interaction sub-system mostly resides in a file called \textit{client\_receive.py}.
% This file first sets up the connection to the video server and after that it listens for messages from the server.
% In our case, messages from the server contain information about the faces in the frame.
% This includes emotion and postion of the face.
% The system decides at the beginning of the conversation with the user what the most dominant emotion of the user is.
% It does this by gathering all detected emotions until the user gives their first input.
% While \textit{client\_receive.py} listens to messages from the server, it also listening for input of the user.
% If the user is done with talking, their message is combined with most dominant emotion .
% This prompt is then given to Gemini, which creates a fitting response.
% We chose Gemini for this project because it is free to use with a Google account and it has a rate limit that we will most likely not reach.
% To make sure Gemini generates a fitting response, it is given a system instruction that precisely describes its role as a bartender.
% The response that is generated by Gemini is then forwarded to furhat so it can reply to the input of the user.
% After this is done, furhat starts listening to the user again and this process is repeated.
% Once Bart finds a fitting cocktail it says `Here you go' and afterwards listens to input from a new user.

\subsubsection{Result}
In the project proposal, we described several objectives that we expect our bartender to fullfill.
We can test our product by confirming it adheres to the set objectives.

One of the objectives is that our product gives recommendations to the user, based on the user's emotional state.
We add the mood of the user to the prompt that we send to Gemini.
Because of this, Gemini will take both the emotion of the user as well as the user's speech into account when generating a response.

Another objective is that Bart should take the user's preferences into account. 
We achieve this by letting Gemini generate questions that explores the needs and preferences of the user.
Gemini incorporates current and previous answers of this user into the recommendation.

The last objective is that the conversation with the system should be pleasant.
This is a more subjective goal, but we try to make the conversation as pleasant as possible by continuously adjusting the prompts given to Gemini.
By doing this, we hope to make the conversation as pleasant as possible.

% - works well in general, it finds a cocktail based on the input of the user relatively quickly
% objectives from specification:
% - come up with recommendations based on emotional state -> reflects on current emotional state of user
% - take the preferences of the client into account -> automatically happens due to prompting of llm
% - make sure the conversation is pleasant -> subjective, hard to tell (conduct interviews etc.)

\section{General Discussion}
Adria\\
The path to selecting the Random Forest model involved several steps and a lot of experimentation with different approaches. First we explored building our own neural networks, specifically multilayer feedforward neural networks using a gradient backpropagation algorithm. We tested various architectures to improve the accuracy of emotion classification. However, this approach was highly time-consuming in terms of training and optimizing the networks. The results were also often unstable, and fine-tuning the neural network models required more resources and time than the scope of our project and expertise would allow.
\\
Next we found a pre-trained model for facial recognition from a competition on Kaggle \textcolor{red}{\textbf(reference to the Kaggle model)}. We experimented with replication of the model adjusted to our own expertise. This did approach did however not lead to desired outcomes. Even though pre-trained models were allowed, we decided against using them unmodified because we wanted the work to reflect our own understanding and contributions. Given that the machine learning model was a major component of the project, relying on someone else’s model did not feel right. \\
Due to this we shifted our focus to other machine learning methods. We experimented with Support Vector Machines (SVM), Boosting models, and finally, Random Forest models. After thorough testing, we found that the Random Forest model had best balance of accuracy and stability even though we would preferably have wanted to have more time to improve its results, this was however not possible considering our work load combined with other courses. The RF-model performance was consistent across test runs, and due to this it ultimately became the chosen model for our system.
\subsection{Overall Pipeline}
Adria
\subsection{Challenges}
Adria
\subsection{Use of ChatGPT and other tools}

ChatGPT has been used to assist in resolving error messages in the code and to discuss different ways to optimize machine learning techniques. The information provided by ChatGPT has been cross-verified with other sources, including GeeksforGeeks and the official Python documentation for specific packages. Using ChatGPT helped streamline our workflow by providing quick solutions to technical challenges and offering alternative approaches to improve model performance. Additionally, it saved significant time during debugging and allowed us to focus on implementing and testing new ideas, ultimately enhancing our understanding of machine learning concepts.

AI has also been used as a proof reader of our project report and gave us valuable help with formulation of sentences and handling of grammatical errors. This significantly improved the flow and readability of our report. 

\subsection{Ethical Issues}
Adria



\section*{Conclusion}
Adria

\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.

\end{thebibliography}

\end{document}